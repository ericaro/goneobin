/*Generated by neobin
 */
package nbr

import (
	"bytes"
	"errors"
	"io"
	"math"
)

const (
	MAGIC = 0x14E0B114
)

type SimulationReceiver interface {
	Name(name string, address string) (err error)

	Timestamp(t int64) (err error)

	Ids(id []int64) (err error)

	Values(x []float32) (err error)

	Eof() (err error)
}

type SimulationReader struct {
	*binReader
	receiver SimulationReceiver
}

func NewSimulationReader(r io.Reader, receiver SimulationReceiver) *SimulationReader {
	reader := &SimulationReader{
		binReader: &binReader{
			r: r,
		},
		receiver: receiver,
	}
	return reader
}

//Parse assumes that the reader has already consumed the magic and the namespace. If not call Parse_Namespace first
func (r *SimulationReader) Parse() (err error) {
	state := 56
	for state >= 0 {
		switch state {
		case 54: // state Values 

			x, err := r.readManyFloat32()
			if err != nil {
				return err
			}

			r.receiver.Values(x)
			state = 53

		case 53: // state Loop 
			tid, err := r.decodeVar()
			if err != nil {
				return err
			}
			switch tid {
			case 0:

				r.receiver.Eof()
				state = -1

			case 1:

				t, err := r.readInt64()
				if err != nil {
					return err
				}

				r.receiver.Timestamp(t)
				state = 55

			default:
				return errors.New("Stream is corrupted. Unknown transition in Loop")
			}
		case 52: // state Data 

			t, err := r.readInt64()
			if err != nil {
				return err
			}

			r.receiver.Timestamp(t)
			state = 55

		case 56: // state Simulation 

			name, err := r.readString()
			if err != nil {
				return err
			}
			address, err := r.readString()
			if err != nil {
				return err
			}

			r.receiver.Name(name, address)
			state = 52

		case 55: // state Ids 

			id, err := r.readManyInt64()
			if err != nil {
				return err
			}

			r.receiver.Ids(id)
			state = 54

		}
	}
	return
}

func (r *SimulationReader) ParseNamespace() (namespace string, err error) {
	magic, err := r.decodeFixed32()
	if magic != MAGIC {
		err = errors.New("illegal magic number")
	}
	if err != nil {
		return
	}
	return r.readString()
}

func NewSimulationWriter(w io.Writer) *Simulation {
	state := &Simulation{
		binWriter: &binWriter{
			w: w,
		},
	}
	state.writeInt32(MAGIC)
	state.writeString("net.ericaro.demo")
	return state
}

//Values
type Values struct {
	*binWriter
}

//Values  transition
func (this *Values) Values(x []float32) *Loop {
	this.writeManyFloat32(x)

	return &Loop{this.binWriter}
}

//Loop
type Loop struct {
	*binWriter
}

//Eof  transition
func (this *Loop) Eof() {
	this.encodeVar(0)

	this.Flush()
}

//Timestamp  transition
func (this *Loop) Timestamp(t int64) *Ids {
	this.encodeVar(1)
	this.writeInt64(t)

	return &Ids{this.binWriter}
}

//Data
type Data struct {
	*binWriter
}

//Timestamp  transition
func (this *Data) Timestamp(t int64) *Ids {
	this.writeInt64(t)

	return &Ids{this.binWriter}
}

//Simulation
type Simulation struct {
	*binWriter
}

//Name  transition
func (this *Simulation) Name(name string, address string) *Data {
	this.writeString(name)
	this.writeString(address)

	return &Data{this.binWriter}
}

//Ids
type Ids struct {
	*binWriter
}

//Ids  transition
func (this *Ids) Ids(id []int64) *Values {
	this.writeManyInt64(id)

	return &Values{this.binWriter}
}

//##################################################################################################
//   PROTOCOLS
//##################################################################################################
type binWriter struct {
	w   io.Writer
	buf bytes.Buffer
	max int
}

func (p *binWriter) append(b ...uint8) {
	p.buf.Write(b)
	if p.buf.Len() > p.max {
		p.Flush()
	}
}
func (p *binWriter) Flush() (err error) {
	_, err = p.buf.WriteTo(p.w)
	return
}

func (p *binWriter) encodeLen(x int) error {
	return p.encodeVar(uint64(x))
}
func (p *binWriter) encodeVar(x uint64) error {
	for x >= 1<<7 {
		p.append(uint8(x&0x7f | 0x80))
		x >>= 7
	}
	p.append(uint8(x))
	return nil
}

func (p *binWriter) encodeFixed32(x uint32) error {
	p.append(
		uint8(x),
		uint8(x>>8),
		uint8(x>>16),
		uint8(x>>24))
	return nil
}
func (p *binWriter) encodeFixed64(x uint64) error {
	p.append(
		uint8(x),
		uint8(x>>8),
		uint8(x>>16),
		uint8(x>>24),
		uint8(x>>32),
		uint8(x>>40),
		uint8(x>>48),
		uint8(x>>56))
	return nil
}

func (p *binWriter) writeByte(x byte) error {
	p.append(x)
	return nil
}
func (p *binWriter) writeString(s string) error {
	p.encodeVar(uint64(len(s)))
	p.append([]byte(s)...)
	return nil
}
func (p *binWriter) writeInt32(x int32) error {
	return p.encodeFixed32(uint32(x))
}
func (p *binWriter) writeInt64(x int64) error {
	return p.encodeFixed64(uint64(x))
}
func (p *binWriter) writeFloat32(x float32) error {
	return p.encodeFixed32(math.Float32bits(x))
}
func (p *binWriter) writeFloat64(x float64) error {
	return p.encodeFixed64(math.Float64bits(x))
}

func (p *binWriter) writeManyByte(x []byte) error {
	p.encodeLen(len(x))
	for _, b := range x {
		err := p.writeByte(b)
		if err != nil {
			return err
		}
	}
	return nil
}

func (p *binWriter) writeManyString(x []string) error {
	p.encodeLen(len(x))
	for _, b := range x {
		err := p.writeString(b)
		if err != nil {
			return err
		}
	}
	return nil
}

func (p *binWriter) writeManyInt32(x []int32) error {
	p.encodeLen(len(x))
	for _, b := range x {
		err := p.writeInt32(b)
		if err != nil {
			return err
		}
	}
	return nil
}

func (p *binWriter) writeManyInt64(x []int64) error {
	p.encodeLen(len(x))
	for _, b := range x {
		err := p.writeInt64(b)
		if err != nil {
			return err
		}
	}
	return nil
}

func (p *binWriter) writeManyFloat32(x []float32) error {
	p.encodeLen(len(x))
	for _, b := range x {
		err := p.writeFloat32(b)
		if err != nil {
			return err
		}
	}
	return nil
}

func (p *binWriter) writeManyFloat64(x []float64) error {
	p.encodeLen(len(x))
	for _, b := range x {
		err := p.writeFloat64(b)
		if err != nil {
			return err
		}
	}
	return nil
}

type binReader struct {
	r   io.Reader
	buf bytes.Buffer
}

func (p *binReader) pull(length int) (err error) {
	tmp := make([]byte, length)
	n, err := p.r.Read(tmp)
	if err != nil {
		return
	}
	p.buf.Write(tmp[0:n])
	return
}

func (p *binReader) getByte() (b byte, err error) {
	// maybe pull before reading
	if p.buf.Len() < 1 {
		p.pull(1024)
	}
	return p.buf.ReadByte()
}

func (p *binReader) get(buf []byte) (n int, err error) {
	// maybe pull before reading
	if p.buf.Len() < len(buf) {

		p.pull(len(buf)) // pull at least what is needed
	}
	return p.buf.Read(buf)
}

func (p *binReader) decodeVar() (x uint64, err error) {
	for shift := uint(0); ; shift += 7 {
		b, err := p.getByte()
		if err != nil {
			return x, err
		}
		x |= (uint64(b) & 0x7F) << shift
		if b < 0x80 {
			break
		}
	}
	return
}
func (p *binReader) decodeFixed64() (x uint64, err error) {
	// x, err already 0
	buf := make([]byte, 8)
	n, err := p.get(buf)
	if err != nil || n < len(buf) {
		err = io.ErrUnexpectedEOF
		return
	}

	x = uint64(buf[0])
	x |= uint64(buf[1]) << 8
	x |= uint64(buf[2]) << 16
	x |= uint64(buf[3]) << 24
	x |= uint64(buf[4]) << 32
	x |= uint64(buf[5]) << 40
	x |= uint64(buf[6]) << 48
	x |= uint64(buf[7]) << 56
	return
}

func (p *binReader) decodeFixed32() (x uint32, err error) {
	// x, err already 0
	buf := make([]byte, 4)
	n, err := p.get(buf)
	if err != nil || n < len(buf) {
		err = io.ErrUnexpectedEOF
		return
	}

	x = uint32(buf[0])
	x |= uint32(buf[1]) << 8
	x |= uint32(buf[2]) << 16
	x |= uint32(buf[3]) << 24
	return
}

func (p *binReader) readByte() (x byte, err error) {
	return p.getByte()
}
func (p *binReader) readString() (s string, err error) {
	size, err := p.decodeVar()
	if err != nil {
		return
	}
	buf := make([]byte, size)
	n, err := p.get(buf)
	if uint64(n) < size {
		err = io.ErrUnexpectedEOF
	}
	if err != nil {
		return
	}
	return string(buf), nil
}

func (p *binReader) readInt32() (x int32, err error) {
	val, err := p.decodeFixed32()
	if err != nil {
		return
	}
	return int32(val), nil
}
func (p *binReader) readInt64() (x int64, err error) {
	val, err := p.decodeFixed64()
	if err != nil {
		return
	}
	return int64(val), nil
}
func (p *binReader) readFloat32() (x float32, err error) {
	code, err := p.decodeFixed32()
	if err != nil {
		return
	}
	return math.Float32frombits(code), nil
}
func (p *binReader) readFloat64() (x float64, err error) {
	code, err := p.decodeFixed64()
	if err != nil {
		return
	}
	return math.Float64frombits(code), nil
}

func (p *binReader) readManyByte() (res []byte, err error) {
	size, err := p.decodeVar()
	if err != nil {
		return res, err
	}
	res = make([]byte, size)
	for i := range res {
		val, err := p.readByte()
		if err != nil {
			return res, err
		}
		res[i] = val
	}
	return res, nil
}

func (p *binReader) readManyString() (res []string, err error) {
	size, err := p.decodeVar()
	if err != nil {
		return res, err
	}
	res = make([]string, size)
	for i := range res {
		val, err := p.readString()
		if err != nil {
			return res, err
		}
		res[i] = val
	}
	return res, nil
}

func (p *binReader) readManyInt32() (res []int32, err error) {
	size, err := p.decodeVar()
	if err != nil {
		return res, err
	}
	res = make([]int32, size)
	for i := range res {
		val, err := p.readInt32()
		if err != nil {
			return res, err
		}
		res[i] = val
	}
	return res, nil
}

func (p *binReader) readManyInt64() (res []int64, err error) {
	size, err := p.decodeVar()
	if err != nil {
		return res, err
	}
	res = make([]int64, size)
	for i := range res {
		val, err := p.readInt64()
		if err != nil {
			return res, err
		}
		res[i] = val
	}
	return res, nil
}

func (p *binReader) readManyFloat32() (res []float32, err error) {
	size, err := p.decodeVar()
	if err != nil {
		return res, err
	}
	res = make([]float32, size)
	for i := range res {
		val, err := p.readFloat32()
		if err != nil {
			return res, err
		}
		res[i] = val
	}
	return res, nil
}

func (p *binReader) readManyFloat64() (res []float64, err error) {
	size, err := p.decodeVar()
	if err != nil {
		return res, err
	}
	res = make([]float64, size)
	for i := range res {
		val, err := p.readFloat64()
		if err != nil {
			return res, err
		}
		res[i] = val
	}
	return res, nil
}
