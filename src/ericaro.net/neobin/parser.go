package neobin

import (
	"ericaro.net/gogrex"
)

//dataType is an internal type to reflect native type supported ( along with their metadata (a simple name was enough)
type dataType string

var (
	byteType   = dataType("byte")   // byte       byte
	intType    = dataType("int")    // int         int
	longType   = dataType("long")   // long       long
	stringType = dataType("string") // string   string
	floatType  = dataType("float")  // float     float
	doubleType = dataType("double") // double   double

	manyMany   = "many" // the "many" options in neobin
	manySingle = "single"
)

// below stuf to be unmarshalled from the standard neobin format.
// for the clarity, we also add some attributes used after the unmarshalling to help in the generation process

// struct dedicated to parsing neobin xml

//neobin is the main file struct.
type neobin struct {
	Package     string  `xml:"package"` // the neobin package, it will be generated as a namepace in the file, so it can't be ignored, but it can't be used neither as a gopackage name
	GoPackage   string  `xml:"-"` // the generated go package name, must be deduced from outside (usually the dirname) 
	Header      *string `xml:"header"` 
	Name        *string `xml:"name"` //optional the language helper class name
	Expression  string  `xml:"expression"` // the regular expression
	grex        *gogrex.Grex // this will contain the grex result of the above expression
	Transitions []*transition `xml:"transitions>transition"` // xml configuration for transitions (@see below)
	States      []*state      `xml:"states>state"` // xml configuration for states (@see below)
}

//transition capture a single edge in the grex.
type transition struct {
	Name      string      `xml:"name,attr"`
	Variables []*variable `xml:"var"`
}

//variable contains the real bottom most data definition.
// its made of:
//  - one the predefined dataType
//  - a name must be unique in the transition
//  - a 'many' enumeration that can be:
//    - "single", the data is written directly
//    - "many", the data is an slice of dataType, a varint is written with the size of the slice ( in numbers of item, not  number of bytes ), then 
//            slice's items are written one by one.
type variable struct {
	Type dataType `xml:"type,attr"`
	Name string   `xml:"name,attr"`
	Many string   `xml:"many,attr"`
}

//state is a state within the grex. The deal is that in a regular expression description, states are implicit. But, it is much more convenient 
// to get a a real name for every state ( this makes the generated code easier to use and understand.
// therefore neobin provides a way to name those states.
// One of the goal of state naming, is to manage that the calling code remain as stable as possible.
type state struct {
	id          int               `xml:"-"` // generated by the compiling process
	Output      bool              `xml:"-"` // compiled, if this states belongs to the grex's outputs
	Input       bool              `xml:"-"` // compiled, if this states belongs is the  grex's inputs
	Choice      bool              `xml:"-"` // compiled, if there are several output edges going out from this state.
	Transitions []*transitionEdge `xml:"-"` // compiled, the slice of output edges ( note the difference in type, a transition is unique, whereas a transitionEdge is attached to every edge in the graph. 
	Path        string            `xml:"path,attr"` // user input: the path entered for this state
	State       string            `xml:",chardata"` // user input: the state's name.
}
