package neobin

import (
	"strings"
	"text/template"
)

func UpperFirst(str string) string {
	return strings.ToUpper(str[0:1]) + str[1:]
}

var (
	funcMap = template.FuncMap{
		// The name "title" is what the function will be called in the template text.
		"uf": UpperFirst,
	}
	FileUnitTemplate = template.Must(template.New("FileUnit").Funcs(funcMap).Parse(FileUnit))
	ProtocolTemplate = template.Must(template.New("Protocol").Funcs(funcMap).Parse(PROTOCOL))
)

const (
	FileUnit = `


{{/*  transition generates a single writer method  */}}
{{define "TransitionWriter"}}
	//{{.Name | uf}}  transition
	func (this *{{.Source.Name| uf}}) {{.Name | uf}}({{range $v := .Variables}}{{$v.Name}} {{if .IsMany}}[]{{end}}{{$v.TypeDef}}, {{end}}){{if not .Dest.Output}}  *{{.Dest.Name| uf}} {{end}}{
			{{if .Source.Choice}}this.encodeVar({{.Id}});
			{{end}}{{range .Variables}}this.write{{if .IsMany}}Many{{end}}{{.EncodeDef | uf}}({{.Name}})
			{{end}}
			{{if .Dest.Output}}this.Flush(){{else}}return &{{.Dest.Name| uf}}{this.binWriter}{{end}}
		}
{{end}}






{{/* state writer generates the writer state */}}
{{define "StateWriter"}}
	{{if not .Output}}
	//{{.Name}}
	type {{.Name | uf}} struct {
		*binWriter
	} {{range .Transitions}}
		{{template "TransitionWriter" .}}
	{{end}}{{end}}{{end}}




{{define "NewWriter"}}
{{with .InputState}}func New{{.Name}}Writer(w io.Writer) *{{.Name}} {
	state := &{{.Name}}{
		binWriter : &binWriter{
			w: w,
		} ,
	}{{end}}
	state.writeInt32(MAGIC)
	state.writeString("{{.PackageName}}")
	return state
}
{{end}}

{{/* generates the readXXX() call */}}
{{define "AtomicReadCall"}}{{range .Variables}}{{.Name}} , err := r.read{{if .IsMany}}Many{{end}}{{.EncodeDef | uf}}()
if err != nil {return err}
{{end}}
{{end}}


{{/* generates a whole transition READ call */}}
{{define "TransitionReadCall"}}
	{{template "AtomicReadCall" .}}
	r.receiver.{{.Name|uf}}({{range .Variables}}{{.Name}},{{end}}    )
	{{if .Dest.Output}}state = -1{{else}} state = {{.Dest.Id}}{{end}}
{{end}}





{{define "TypeDef"}} {{.Name}} {{if .IsMany}}[]{{end}}{{.EncodeDef}}{{end}}
{{define "TransitionReadDef"}}{{.Name|uf}}( {{range .Variables}}{{template "TypeDef" .}}, {{end}}) (err error){{end}}


{{define "Receiver"}}
type {{.InputState.Name}}Receiver interface {
	{{range .UniqueTransitions}}
		{{template "TransitionReadDef" .}}
	{{end}}
}
{{end}}




{{/* generates the whole Parser */}}
{{define "ParserReader"}}
{{with .InputState}}//Parse assumes that the reader has already consumed the magic and the namespace. If not call Parse_Namespace first
	func (r *{{.Name}}Reader) Parse() (err error){
	state := {{.Id}}{{end}}
	for state >= 0 {
		switch state { {{range .States}} {{if not .Output}}
				case {{.Id}} : // state {{.Name}} {{if .Choice}}
					tid, err := r.decodeVar()
					if err != nil {return err} 
					switch tid { {{range .Transitions}}
						case {{.Id}}:
							{{template "TransitionReadCall" .}} {{end}}
						default:
							return errors.New("Stream is corrupted. Unknown transition in {{.Name}}")
					} {{else}}
					{{template "TransitionReadCall" .Single}} {{end}} {{end}} {{end}}
		}
	}
	return
}
{{end}}

{{define "NewReader"}}
{{with .InputState}}func New{{.Name}}Reader(r io.Reader, receiver {{.Name}}Receiver ) *{{.Name}}Reader {
	reader := &{{.Name}}Reader{
		binReader : &binReader{
			r: r,
		} ,
		receiver: receiver,
	}{{end}}
	return reader
}
{{end}}



{{define "Reader"}}
{{$name := .InputState.Name}}
type {{$name}}Reader struct {
	*binReader
	receiver {{$name}}Receiver
}


{{template "NewReader" .}}
{{template "ParserReader" .}}
func (r *{{$name}}Reader) ParseNamespace() (namespace string, err error){
	magic, err := r.decodeFixed32()
	if magic != MAGIC {
		err =  errors.New("illegal magic number")
	}
	if err != nil  {
		return
	}
	return r.readString()
}
{{end}}



{{/*main: generates the whole file*/}}
/*Generated by neobin
*/
package {{.GoPackage}}

import (
	"io"
	"math"
	"errors"
	"bytes"
)

const (
	MAGIC =  0x14E0B114
)


{{template "Receiver" .}}
{{template "Reader" .}}




{{template "NewWriter" .}}

{{range .States}}
	{{template "StateWriter" .}}
{{end}}

`

	PROTOCOL = `//##################################################################################################
//   PROTOCOLS
//##################################################################################################
type binWriter struct {
	w io.Writer
	buf bytes.Buffer
	max int
}

func (p *binWriter) append(b ...uint8) {
	p.buf.Write(b)
	if p.buf.Len() > p.max {
		p.Flush()
	}
}
func (p *binWriter) Flush() (err error) {
	_, err = p.buf.WriteTo(p.w)
	return
}

func (p *binWriter) encodeLen(x int) error {
	return p.encodeVar(uint64(x) )
}
func (p *binWriter) encodeVar(x uint64) error {
	for x >= 1<<7 {
		p.append(uint8(x&0x7f | 0x80))
		x >>= 7
	}
	p.append(uint8(x))
	return nil
}

func (p *binWriter) encodeFixed32(x uint32) error {
	p.append(
		uint8(x),
		uint8(x>>8),
		uint8(x>>16),
		uint8(x>>24))
	return nil
}
func (p *binWriter) encodeFixed64(x uint64) error {
	p.append(
		uint8(x),
		uint8(x>>8),
		uint8(x>>16),
		uint8(x>>24),
		uint8(x>>32),
		uint8(x>>40),
		uint8(x>>48),
		uint8(x>>56))
	return nil
}

{{/*TODO generate all the reads Too, and handle read errors*/}}
func (p *binWriter) writeByte(x byte) error {
	p.append(x)
	return nil
}
func (p *binWriter) writeString(s string) error {
	p.encodeVar(uint64(len(s)))
	p.append([]byte(s)...)
	return nil
}
func (p *binWriter) writeInt32(x int32) error {
	return p.encodeFixed32( uint32(x) ) 
}
func (p *binWriter) writeInt64(x int64) error {
	return p.encodeFixed64( uint64(x) ) 
}
func (p *binWriter) writeFloat32(x float32) error {
	return p.encodeFixed32( math.Float32bits(x) )
}
func (p *binWriter) writeFloat64(x float64) error {
	return p.encodeFixed64( math.Float64bits(x) )
}

{{define "WriteMany"}}
func (p *binWriter) writeMany{{.|uf}}(x []{{.}}) error {
	p.encodeLen(len(x) )
	for _,b := range x {
		err := p.write{{.|uf}}(b)
		if err != nil {return err}
	}
	return nil
}
{{end}}

{{template "WriteMany" "byte" }}
{{template "WriteMany" "string" }}
{{template "WriteMany" "int32" }}
{{template "WriteMany" "int64" }}
{{template "WriteMany" "float32" }}
{{template "WriteMany" "float64" }}




type binReader struct {
	r io.Reader
	buf bytes.Buffer
}


func (p *binReader) pull(length int) (err error){
	tmp := make([]byte, length)
	n, err := p.r.Read(tmp)
	if err != nil {
		return
	}
	p.buf.Write(tmp[0:n] )
	return 
}

func (p *binReader) getByte() (b byte, err error) {
		// maybe pull before reading
		if p.buf.Len()<1 {
			p.pull(1024)
		}
		return p.buf.ReadByte()
}

func (p *binReader) get(buf []byte) (n int, err error) {
		// maybe pull before reading
		if p.buf.Len() < len(buf) {
			
			p.pull(len(buf)) // pull at least what is needed
		}
		return p.buf.Read(buf)
}

func (p *binReader) decodeVar() (x uint64, err error) {
	for shift := uint(0); ; shift += 7 {
		b, err := p.getByte()
		if err != nil {
			return x, err
		}
		x |= (uint64(b) & 0x7F) << shift
		if b < 0x80 {
			break
		}
	}
	return
}
func (p *binReader) decodeFixed64() (x uint64, err error) {
	// x, err already 0
	buf := make( []byte, 8)
	n, err := p.get(buf)
	if err != nil || n<len(buf) {
		err = io.ErrUnexpectedEOF
		return
	}
	
	x  = uint64(buf[0])
	x |= uint64(buf[1]) << 8
	x |= uint64(buf[2]) << 16
	x |= uint64(buf[3]) << 24
	x |= uint64(buf[4]) << 32
	x |= uint64(buf[5]) << 40
	x |= uint64(buf[6]) << 48
	x |= uint64(buf[7]) << 56
	return
}

func (p *binReader) decodeFixed32() (x uint32, err error) {
	// x, err already 0
	buf := make( []byte, 4)
	n, err := p.get(buf)
	if err != nil || n<len(buf) {
		err = io.ErrUnexpectedEOF
		return
	}

	x  = uint32(buf[0])
	x |= uint32(buf[1]) << 8
	x |= uint32(buf[2]) << 16
	x |= uint32(buf[3]) << 24
	return
}


func (p *binReader) readByte()(x byte, err error) {
	return p.getByte()
}
func (p *binReader) readString()(s string, err error) {
	size, err := p.decodeVar()
	if err != nil {return}
	buf := make([]byte, size)
	n, err := p.get(buf)
	if uint64(n)<size { 
	err = io.ErrUnexpectedEOF 
	}
	if err != nil {return}
	return string(buf), nil
}

func (p *binReader) readInt32()(x int32, err error) {
	val, err := p.decodeFixed32()
	if err != nil {return}
	return int32(val), nil
}
func (p *binReader) readInt64()(x int64, err error) {
	val, err := p.decodeFixed64()
	if err != nil {return}
	return int64(val), nil
}
func (p *binReader) readFloat32()(x float32, err error) {
	code, err := p.decodeFixed32()
	if err != nil {return}
	return math.Float32frombits(code), nil
}
func (p *binReader) readFloat64()(x float64, err error) {
	code, err := p.decodeFixed64()
	if err != nil {return}
	return math.Float64frombits(code), nil
}



{{define "ReadMany"}}
func (p *binReader) readMany{{.|uf}}() (res []{{.}}, err error) {
	size, err  := p.decodeVar()
	if err != nil {return res, err}
	res = make([]{{.}}, size)
	for i := range res {
		val, err := p.read{{.|uf}}()
		if err != nil {return res, err}
		res[i] = val
	}
	return res, nil
}
{{end}}

{{template "ReadMany" "byte" }}
{{template "ReadMany" "string" }}
{{template "ReadMany" "int32" }}
{{template "ReadMany" "int64" }}
{{template "ReadMany" "float32" }}
{{template "ReadMany" "float64" }}




`
)
